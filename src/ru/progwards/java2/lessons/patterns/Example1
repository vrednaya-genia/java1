public class StatisticInfo {
    public String sectionName; // - имя секции
    public long fullTime; // - полное время выполнения секции в наносекундах.
    public long selfTime; // - чистое время выполнения секции в наносекундах.
                          // Для вложенных секций,
                          // из времени выполнения внешней секции нужно вычесть времена выполнения вложенных секций.
    public int count;

    @Override
    public String toString() {
        return "StatisticInfo{" +
                "sectionName='" + sectionName + '\'' +
                ", fullTime=" + fullTime/1000000 +         // для перевода в милисекунды
                ", selfTime=" + selfTime/1000000 +         // для перевода в милисекунды
                ", count=" + count +
                '}';
    }

    public StatisticInfo(String sectionName, long fullTime, long selfTime, int count) {
        this.sectionName = sectionName;
        this.fullTime = fullTime;
        this.selfTime = selfTime;
        this.count = count;
    }
}


import java.util.*;

public enum  SingletonProfiler {
    INSTANSE ();

    private long timeTemp = 0;   // - время работы вложенной секции
    private Integer countVlozSec = 0;  // - счетчик работающих вложенных секций
    private boolean vlozInc;                      // вход в новую секцию?

    private Map<String, StatisticInfo> profilMapResult = new TreeMap<>();
    private Map<String, Long> rabota = new TreeMap<>();
    private Map<String, LinkedList<Long>> vlozTempTime = new HashMap<>();

    SingletonProfiler(){}

    public void enterSection(String name, Thread thread) {
        name += " " + thread.getName();
        countVlozSec++;
        if (countVlozSec > 1 && !vlozInc) {    // если при открытых секциях после закрытия не всех снова пошёл вход
            for (var entry: vlozTempTime.entrySet()) {           // сохраняем время работы вложенных секций до этого
                for (Long time: entry.getValue()) {
                    time += timeTemp;
                }
            }
            timeTemp = 0;
        }
        LinkedList<Long> list = vlozTempTime.containsKey(name) ? vlozTempTime.get(name) : new LinkedList<>();
        list.push(0L);
        vlozTempTime.put(name, list);
        rabota.put(name, System.nanoTime());
        vlozInc = true;
    }

    public void exitSection(String name, Thread thread) {
        name += " " + thread.getName();
        countVlozSec--;
        long fulltimeS = System.nanoTime()-rabota.get(name);
        long selftimeS = fulltimeS - timeTemp - vlozTempTime.get(name).pop();
        if (vlozTempTime.get(name).isEmpty())
            vlozTempTime.remove(name);
        timeTemp = countVlozSec != 0 ? fulltimeS : 0;

        StatisticInfo stillNot = profilMapResult.putIfAbsent(name, new StatisticInfo(name, fulltimeS, selftimeS, 1));
        if (stillNot != null) {
            profilMapResult.get(name).fullTime += fulltimeS;
            profilMapResult.get(name).selfTime += selftimeS;
            profilMapResult.get(name).count++;
        }
        vlozInc = false;
    }

    public List<StatisticInfo> getStatisticInfo() {
        ArrayList<StatisticInfo> itog = new ArrayList<>();
        for (var entry: profilMapResult.entrySet())
            itog.add(entry.getValue());
        return itog;
    }
}


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class CheckSingletonProfiler {
    int counter = 0;
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();

    public synchronized void inc(SingletonProfiler sp) {
        sp.enterSection("inc",Thread.currentThread());
        counter++;
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        sp.enterSection("inc",Thread.currentThread());
    }

    public synchronized void dec (SingletonProfiler sp) {
        sp.enterSection("dec", Thread.currentThread());

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        sp.exitSection("dec", Thread.currentThread());
    }

    public static void main(String[] args) {
        CheckSingletonProfiler csp = new CheckSingletonProfiler();
        Thread [] threads = new Thread[11];
        SingletonProfiler[] singletonProfilers = new SingletonProfiler[11];
        for (int i=0; i<threads.length; i++) {
            int finalI = i;
            threads[i] = new Thread(() -> {
                singletonProfilers[finalI] = SingletonProfiler.INSTANSE;
                System.out.println("до " + finalI + " = " + csp.counter);

                if (finalI %2 == 0)
                    csp.inc(singletonProfilers[finalI]);
                else csp.dec(singletonProfilers[finalI]);

                if (finalI %3 ==0)
                    csp.dec(singletonProfilers[finalI]);

                System.out.println("после" + finalI + " = "+ csp.counter);

            });
        }
        for (int i=0; i<threads.length; i++) {
            threads[i].start();
        }
        for (int i = 0; i< threads.length; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println(csp.counter);
        System.out.println(SingletonProfiler.INSTANSE.getStatisticInfo());
    }
}